package main

import (
	"errors"
	"fmt"
	"os"
	"strconv"
	"strings"

	"golang.org/x/net/html"
	"golang.org/x/net/html/atom"

	"github.com/mavolin/standards/iso3166"
)

func main() {
	if err := run(); err != nil {
		panic(err)
	}
}

func run() error {
	// table needs to marked with id="IBAN_formats_by_country_table"
	in, err := os.Open("in.html")
	if err != nil {
		return err
	}
	defer in.Close()

	n, err := html.Parse(in)
	if err != nil {
		return err
	}

	var rawRules map[iso3166.Alpha2Code][2]string

	walk(n, func(n *html.Node) (dive, stop bool) {
		if n.DataAtom != atom.Table {
			return true, false
		}

		for _, attr := range n.Attr {
			if attr.Key != "id" {
				continue
			} else if attr.Val != "IBAN_formats_by_country_table" {
				continue
			}

			// we found our table

			tbody := n.FirstChild
			for tbody != nil {
				if tbody.DataAtom == atom.Tbody {
					break
				}
				tbody = tbody.NextSibling
			}

			rawRules, err = extractRawRulesFromTable(tbody)
			return false, false
		}

		return true, false
	})
	if err != nil {
		return err
	}

	if len(rawRules) == 0 {
		return errors.New("could not find table")
	}

	f, err := os.Create("bban_regexps.go")
	if err != nil {
		return err
	}

	rules, err := genRules(rawRules)
	if err != nil {
		return err
	}

	fmt.Fprintln(f, "package", os.Getenv("GOPACKAGE"))
	fmt.Fprintln(f)
	fmt.Fprintln(f, "import (")
	fmt.Fprintln(f, "\t\"regexp\"")
	fmt.Fprintln(f)
	fmt.Fprintln(f, "\t\"github.com/mavolin/standards/iso3166\"")
	fmt.Fprintln(f, ")")
	fmt.Fprintln(f, "// Code generated by tools/codegen/bban_regexp; DO NOT EDIT.")
	fmt.Fprintln(f)
	fmt.Fprintln(f, "var bbanRegexps = map[iso3166.Alpha2Code]*regexp.Regexp{")

	for code, rawRegexp := range rules {
		fmt.Fprintf(f, "\tiso3166.%s: regexp.MustCompile(%q),\n", code.Code, rawRegexp)
	}

	fmt.Fprintln(f, "}")

	return nil
}

func extractRawRulesFromTable(tbody *html.Node) (map[iso3166.Alpha2Code][2]string, error) {
	rawRules := make(map[iso3166.Alpha2Code][2]string)

	tr := nextElement(tbody.FirstChild)

	for tr != nil {
		var rawCountryCode string

		countryEl := nextElement(tr.FirstChild)
		charsEl := nextElement(countryEl.NextSibling)
		charClassesEl := nextElement(charsEl.NextSibling)
		formatEl := nextElement(charClassesEl.NextSibling)

		charClasses := charClassesEl.FirstChild.Data
		charClasses = strings.ReplaceAll(charClasses, " ", "")
		charClasses = strings.ReplaceAll(charClasses, "\n", "")

		var formatBuilder strings.Builder

		codeEl := formatEl.FirstChild

		countryCodeEl := codeEl.FirstChild
		rawCountryCode = countryCodeEl.FirstChild.FirstChild.Data

		checkDigitsEl := nextElement(countryCodeEl.NextSibling)

		bbanEl := checkDigitsEl.NextSibling
		for bbanEl != nil {
			switch bbanEl.Type { //nolint:exhaustive
			case html.TextNode:
				formatBuilder.WriteString(bbanEl.Data)
			case html.ElementNode:
				formatBuilder.WriteString(bbanEl.FirstChild.Data)
			}

			bbanEl = bbanEl.NextSibling
		}

		countryCode, err := iso3166.ParseAlpha2(rawCountryCode)
		if err != nil {
			return nil, err
		}

		format := strings.ReplaceAll(formatBuilder.String(), " ", "")
		format = strings.ReplaceAll(format, "\n", "")
		rawRules[countryCode] = [2]string{charClasses, format}

		tr = nextElement(tr.NextSibling)
	}

	return rawRules, nil
}

func walk(n *html.Node, f func(*html.Node) (dive, stop bool)) (stop bool) {
	for n != nil {
		dive, stop := f(n)
		if stop {
			return true
		}
		if dive {
			stop = walk(n.FirstChild, f)
			if stop {
				return stop
			}
		}

		n = n.NextSibling
	}

	return false
}

func nextElement(n *html.Node) *html.Node {
	for n != nil {
		if n.Type == html.ElementNode {
			return n
		}

		n = n.NextSibling
	}

	return nil
}

func genRules(rawRules map[iso3166.Alpha2Code][2]string) (map[iso3166.Alpha2Code]string, error) {
	// map[iso3166.Alpha2Code]rawRegexp
	rules := make(map[iso3166.Alpha2Code]string, len(rawRules))

	for country, rule := range rawRules {
		rawLengths := strings.Split(rule[0], ",")
		format := strings.ReplaceAll(rule[1], " ", "")

		// a regexp for each character in the bban
		rawPerCharRegexp := make([]string, 0, len(format))

		for _, rawLength := range rawLengths {
			class := rawLength[len(rawLength)-1]
			length, err := strconv.Atoi(rawLength[:len(rawLength)-1])
			if err != nil {
				return nil, err
			}

			var regexpEquiv string
			switch class {
			case 'a':
				regexpEquiv = `[A-Z]`
			case 'n':
				regexpEquiv = `\d`
			case 'c':
				regexpEquiv = `[\dA-Z]`
			}

			rawPerCharClassRegexp := make([]string, length)
			for i := range rawPerCharClassRegexp {
				rawPerCharClassRegexp[i] = regexpEquiv
			}
			rawPerCharRegexp = append(rawPerCharRegexp, rawPerCharClassRegexp...)
		}

		if len(rawPerCharRegexp) != len(format) {
			panic(country.Country + ": length of rawPerCharRegexp and format do not match")
		}

		var sb strings.Builder

		var currentVerb rune
		for i, r := range format {
			if r != currentVerb {
				if i > 0 {
					sb.WriteString(")")
				}

				name := verbToName[r]
				if name == "" {
					sb.WriteString("(?:")
				} else {
					sb.WriteString("(?P<")
					sb.WriteString(name)
					sb.WriteString(">")
				}

				currentVerb = r
			}

			sb.WriteString(rawPerCharRegexp[i])
		}

		sb.WriteString(")")

		rules[country] = sb.String()
	}

	return rules, nil
}

var verbToName = map[rune]string{
	'0': "",
	'a': "balanceAccountNumber",
	'b': "bankCode",
	'c': "accountNumber",
	'i': "ownerIdentificationNumber",
	'm': "currencyCode",
	'n': "ownerAccountNumber",
	'p': "accountNumberPrefix",
	'q': "bicBankCode",
	's': "branchCode",
	't': "accountType",
	'x': "checksum",
}
