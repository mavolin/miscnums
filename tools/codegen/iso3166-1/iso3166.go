// Command iso3166-1 generates [iso3166.Alpha2Code] structs for all iso3166-1
// country codes.
//
// The current implementation decodes HTML downloaded (the iso site client-side
// renders their page) by the user from the official iso.org site containing a
// table with all alpha-2 codes.
// That table is read in decoded into individual [iso3166.Alpha2Code] structs.
// As of now, this is the easiest (and cheapest!) way of getting accurate,
// official information.
//
// Download the HTML at https://www.iso.org/obp/ui/#iso:pub:PUB500001:en to
// use this program.
package main

import (
	"errors"
	"fmt"
	"os"

	"golang.org/x/net/html"
	"golang.org/x/net/html/atom"

	"github.com/mavolin/standards/iso3166"
)

func main() {
	if err := run(); err != nil {
		panic(err)
	}
}

func run() error {
	in, err := os.Open("in.html")
	if err != nil {
		return err
	}
	defer in.Close()

	n, err := html.Parse(in)
	if err != nil {
		return err
	}

	var codes []iso3166.Alpha2Code

	walk(n, func(n *html.Node) (dive, stop bool) {
		if n.DataAtom != atom.Table {
			return true, false
		}

		for _, attr := range n.Attr {
			if attr.Key != "class" {
				continue
			} else if attr.Val != "grs-grid" {
				continue
			}

			// we found our table

			if n.FirstChild == nil || n.FirstChild != n.LastChild /* len(ChildNodes) != 1 */ || n.FirstChild.DataAtom != atom.Tbody {
				panic("expected country code table to contain a single node, named tbody")
			}

			codes, err = extractCountryCodesFromTable(n.FirstChild)
			return false, false
		}

		return true, false
	})
	if err != nil {
		return err
	}

	if len(codes) == 0 {
		return errors.New("could not find table")
	}

	out, err := os.Create("codes.go")
	if err != nil {
		return err
	}

	fmt.Fprintln(out, "package", os.Getenv("GOPACKAGE"))
	fmt.Fprintln(out)
	fmt.Fprintln(out, "// Code generated by tools/codegen/iso3166-1. DO NOT EDIT.")
	fmt.Fprintln(out)

	fmt.Fprintln(out, "var (")
	for _, code := range codes {
		fmt.Fprintf(out, "\t%s = Alpha2Code{\n", code.Code)
		fmt.Fprintf(out, "\t\tCode:    %q,\n", code.Code)
		fmt.Fprintf(out, "\t\tStatus:  %d,\n", code.Status)
		fmt.Fprintf(out, "\t\tCountry: %q,\n", code.Country)
		fmt.Fprintf(out, "\t}\n") // Fprintf for consistency
	}
	fmt.Fprintln(out, ")")

	fmt.Fprintln(out)

	fmt.Fprintln(out, "var alpha2Codes = map[string]Alpha2Code{")
	for _, code := range codes {
		fmt.Fprintf(out, "\t%q: %s,\n", code.Code, code.Code)
	}
	fmt.Fprintln(out, "}")

	return nil
}

func extractCountryCodesFromTable(tbody *html.Node) ([]iso3166.Alpha2Code, error) {
	codes := make([]iso3166.Alpha2Code, 0, 26*26)

	tr := tbody.FirstChild
	for tr != nil {
		td := tr.FirstChild
		for td != nil {
			var code iso3166.Alpha2Code

			for _, attr := range td.Attr {
				switch attr.Key {
				case "class":
					status, err := statusFromClass(attr.Val)
					if err != nil {
						return nil, err
					}

					code.Status = status
				case "title":
					code.Country = attr.Val
				}
			}

			if code.Status == 0 {
				return nil, errors.New("td has no class attribute")
			}

			// two cases, either td contains the name, or an anchor containing the name

			switch td.FirstChild.Type { //nolint:exhaustive
			case html.TextNode:
				code.Code = td.FirstChild.Data
			case html.ElementNode:
				code.Code = td.FirstChild.FirstChild.Data
			default:
				return nil, errors.New("unexpected node type of td's first child")
			}

			codes = append(codes, code)

			td = td.NextSibling
		}

		tr = tr.NextSibling
	}

	return codes, nil
}

func walk(n *html.Node, f func(*html.Node) (dive, stop bool)) (stop bool) {
	for n != nil {
		dive, stop := f(n)
		if stop {
			return true
		}
		if dive {
			stop = walk(n.FirstChild, f)
			if stop {
				return stop
			}
		}

		n = n.NextSibling
	}

	return false
}

func statusFromClass(class string) (iso3166.Status, error) {
	switch class {
	case "grs-status0":
		return iso3166.Unassigned, nil
	case "grs-status1":
		return iso3166.OfficiallyAssigned, nil
	case "grs-status2":
		return iso3166.UserAssigned, nil
	case "grs-status3":
		return iso3166.ExceptionallyReserved, nil
	case "grs-status4":
		return iso3166.TransitionallyReserved, nil
	case "grs-status5":
		return iso3166.IndeterminatelyReserved, nil
	case "grs-status6":
		return iso3166.IndeterminatelyReserved, nil
	default:
		return 0, fmt.Errorf("unrecognized class %s", class)
	}
}
